<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>テスト</title>
</head><body style="margin: 0; overflow: hidden;">
	<div>Hello World</div>
	<video id="testVideo" width="256" height="256" autoplay muted playsinline></video>
	<!-- -------- 頂点シェーダー -------- -->
	<script id="vshader_src" type="x-shader/x-vertex">
		precision highp float;
		attribute vec3 vs_attr_pos;
		attribute vec2 vs_attr_uvc;
		varying vec2 texCoord;
		void main(){
			texCoord = vs_attr_uvc;
			gl_Position = vec4(vs_attr_pos, 1.0);
		}
	</script>
	<!-- -------- フラグメントシェーダー -------- -->
	<script id="fshader_src" type="x-shader/x-fragment">
		precision highp float;
		uniform sampler2D texture;
		varying vec2 texCoord;
		void main(){
			gl_FragColor = texture2D(texture, texCoord);
		}
	</script>
	<script type="text/javascript">
// ----------------------------------------------------------------
// ----------------------------------------------------------------
// ----------------------------------------------------------------

document.addEventListener("DOMContentLoaded", e => {
	true && (() => {
		const callback = `call${Math.floor(Math.random() * 0xffff)}`;
		Promise.resolve().then(() => new Promise(resolve => {
			const value1 = "test";
			window.fuhahaCallbacks = window.fuhahaCallbacks || {};
			window.fuhahaCallbacks[callback] = resolve;
			window.webkit && window.webkit.messageHandlers.fuhahaAction.postMessage({ callback, value1, });
		})).then(value2 => {
			delete window.fuhahaCallbacks[callback];
			window.webkit && window.webkit.messageHandlers.nativeAction.postMessage(value2);
		});
	})();

	true && (() => {
		// キャンバス作成
		const canvas = document.createElement("canvas");
		canvas.width = 100;
		canvas.height = 100;
		const context = canvas.getContext("2d");

		// ビデオ設定
		const stream = canvas.captureStream(10);
		document.getElementById("testVideo").srcObject = stream;
		//document.getElementById("testVideo").src = URL.createObjectURL(stream)

		// キャンバス描画
		const colors = ["#ff0000", "#00ff00", "#0000ff", "#00ffff", "#ff00ff", "#ffff00",];
		context.fillStyle = colors[Math.floor(Math.random() * colors.length)];
		context.fillRect(0, 0, canvas.width, canvas.height);
		(draw => {
			const loop = () => {
				draw();
				window.requestAnimationFrame(loop);
			};
			loop();
		})(() => {
			const r = 10;
			const x = Math.floor(Math.random() * (canvas.width - 2 * r)) + r;
			const y = Math.floor(Math.random() * (canvas.height - 2 * r)) + r;
			context.beginPath();
			context.fillStyle = colors[Math.floor(Math.random() * colors.length)];
			context.arc(x, y, r, 0, 2 * Math.PI, false);
			context.fill();
		});
	})();

	true && (() => {
		const canvas = document.createElement("canvas");
		canvas.width = 512;
		canvas.height = 512;

		document.body.appendChild(canvas);
//		// ビデオ設定
//		const stream = canvas.captureStream(10);
//		document.getElementById("testVideo").srcObject = stream;
//		document.getElementById("testVideo").play();

		const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
		if(!gl){ return; }
		window.gl = gl;

		// 頂点シェーダーの作成
		const vshader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vshader, document.getElementById("vshader_src").textContent);
		gl.compileShader(vshader);
		// フラグメントシェーダーの作成
		const fshader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fshader, document.getElementById("fshader_src").textContent);
		gl.compileShader(fshader);
		// プログラムオブジェクトを作成
		const program = gl.createProgram();
		gl.attachShader(program, vshader);
		gl.attachShader(program, fshader);
		gl.linkProgram(program);
		const attrPos = gl.getAttribLocation(program, "vs_attr_pos");
		const attrUvc = gl.getAttribLocation(program, "vs_attr_uvc");
		// シェーダーを指定
		gl.useProgram(program);
		gl.enableVertexAttribArray(attrPos);
		gl.enableVertexAttribArray(attrUvc);

		// opengl描画設定
		gl.clearColor(0.0, 0.0, 1.0, 1.0);
		//gl.enable(gl.TEXTURE_2D);

		// 頂点配列作成
		const vert = [
			-0.8, -0.8, 0.0,
			 0.8, -0.8, 0.0,
			 0.8,  0.8, 0.0,
			-0.8,  0.8, 0.0,
		];
		const vertBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vert), gl.STATIC_DRAW);
		// テクスチャ座標配列作成
		const texc = [
			0.0, 1.0,
			1.0, 1.0,
			1.0, 0.0,
			0.0, 0.0,
		];
		const texcBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, texcBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texc), gl.STATIC_DRAW);
		// 頂点インデックス配列作成
		const face = [
			0, 1, 2,
			0, 2, 3,
		];
		const faceBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(face), gl.STATIC_DRAW);

		// テクスチャ作成
		const textureCanvas = document.createElement("canvas");
		textureCanvas.width = 128;
		textureCanvas.height = 128;
		const textureContext = textureCanvas.getContext("2d");
		textureContext.fillStyle = "white";
		textureContext.fillRect(0, 0, textureCanvas.width, textureCanvas.height);
		textureContext.fillStyle = "red";
		textureContext.fillRect(0, 0, textureCanvas.width, textureCanvas.height);
		const textureObject = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, textureObject);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
		gl.generateMipmap(gl.TEXTURE_2D);
		// テクスチャ情報
		window.webkit && window.webkit.messageHandlers.textureAction.postMessage({  width: textureCanvas.width, height: textureCanvas.height, });
		// テクスチャ更新
		window.textureUpdate = buffer => {
			const xoffset = 0;
			const yoffset = 0
			const width = textureCanvas.width;
			const height = textureCanvas.height;
			const pixels = new Uint8Array(buffer);
			gl.bindTexture(gl.TEXTURE_2D, textureObject);
			gl.texSubImage2D(gl.TEXTURE_2D, 0, xoffset, yoffset, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
			gl.generateMipmap(gl.TEXTURE_2D);
		};

		// メインループ
		(draw => {
			const loop = () => {
				draw();
				window.requestAnimationFrame(loop);
			};
			loop();
		})(() => {
			gl.clear(gl.COLOR_BUFFER_BIT);

			// テクスチャバインド
			gl.bindTexture(gl.TEXTURE_2D, textureObject);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			// バッファバインド
			gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
			gl.vertexAttribPointer(attrPos, 3, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, texcBuffer);
			gl.vertexAttribPointer(attrUvc, 2, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
			// 描画
			const offset = 0;
			const count = face.length;
			gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, offset * Uint16Array.BYTES_PER_ELEMENT);

			gl.flush();
		});
	})();
});

// ----------------------------------------------------------------
// ----------------------------------------------------------------
// ----------------------------------------------------------------
	</script>
</body></html>
